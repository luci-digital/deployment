Overview

This README provides a detailed overview of the GitHub repository and branch structure for the Luci Digital platform. The repository is organized to facilitate collaboration, code management, deployment processes, and version control. The structure is designed to support CI/CD pipelines, ensure clear separation of concerns, and manage the various components of the platform such as AI, blockchain, LoRaWAN integration, and security protocols.
Repository Structure

bash

luci-digital/
│
├── README.md                # Main project README
├── LICENSE.md               # License information
├── CONTRIBUTING.md          # Guidelines for contributing to the project
├── .github/                 # GitHub-specific configurations
│   ├── ISSUE_TEMPLATE/      # Templates for issue submissions
│   ├── PULL_REQUEST_TEMPLATE.md # Template for pull request submissions
│   └── workflows/           # CI/CD workflows (e.g., GitHub Actions)
│       ├── ci.yml           # Continuous Integration pipeline
│       ├── cd.yml           # Continuous Deployment pipeline
│       └── test.yml         # Automated testing workflow
│
├── docs/                    # Documentation for the project
│   ├── architecture.md      # High-level architecture overview
│   ├── API.md               # API documentation
│   └── deployment.md        # Detailed deployment guide
│
├── src/                     # Source code for the Luci Digital platform
│   ├── ai/                  # AI-related code (PyTorch, TensorFlow)
│   │   ├── lucia_ai/        # Daryl’s personal AI (Lucia AI)
│   │   └── agent_ai/        # General client AI agents
│   ├── blockchain/          # Smart contracts, DID issuance, tokenization
│   │   ├── contracts/       # Smart contracts (Solidity, Hedera SDK)
│   │   └── identity/        # DID management and Hedera integration
│   ├── lora/                # LoRaWAN network integration
│   └── security/            # Security configurations and protocols
│       ├── ssl/             # SSL/TLS encryption scripts
│       └── firewall/        # Firewall and network segmentation configurations
│
├── scripts/                 # Automation and deployment scripts
│   ├── setup/               # Initial setup scripts (e.g., installation, dependencies)
│   ├── deploy/              # Scripts for deployment to various environments
│   └── backup/              # Backup and disaster recovery scripts
│
├── tests/                   # Test cases and frameworks
│   ├── unit/                # Unit tests for individual components
│   └── integration/         # Integration tests for multi-component interactions
│
└── config/                  # Configuration files for various services
    ├── ci-cd/               # CI/CD pipeline configurations
    ├── docker/              # Docker Compose and Dockerfiles for containerized services
    └── services/            # Configuration for external services (e.g., cloud, blockchain)

Branching Strategy

The repository follows a Gitflow branching model to ensure a clear and structured approach to development and deployment. Below are the key branches in this strategy:

    main
        Purpose: This is the stable branch that contains production-ready code. It represents the latest release of the platform.
        Access: Direct pushes to the main branch are restricted. Only pull requests from the release branch are merged after passing CI/CD checks.

    develop
        Purpose: The primary branch for active development. All new features and bug fixes are merged into this branch. It represents the next release's working version.
        Access: Feature branches are merged into develop via pull requests, after passing code reviews and testing.

    feature/<feature-name>
        Purpose: Each new feature or enhancement is developed in its own feature branch. These branches are created off of develop and merged back into develop when completed.
        Naming: Feature branches follow the format feature/<feature-name> (e.g., feature/did-issuance, feature/lora-integration).

    hotfix/<hotfix-name>
        Purpose: Hotfix branches are created to address critical issues or bugs found in production. These branches are created off of main and are merged back into both main and develop once the issue is resolved.
        Naming: Hotfix branches follow the format hotfix/<hotfix-name> (e.g., hotfix/ssl-vulnerability).

    release/<version>
        Purpose: Release branches prepare the code for production deployment. Once all features for a release cycle are integrated and tested, the develop branch is merged into a release branch for final testing and review before being merged into main.
        Naming: Release branches follow the format release/<version> (e.g., release/1.0.0).

    bugfix/<bug-name>
        Purpose: Bugfix branches are used for non-critical bug fixes during development. These branches are created off of develop and merged back into develop once the fix is complete.
        Naming: Bugfix branches follow the format bugfix/<bug-name> (e.g., bugfix/login-error).

Deployment Pipelines

Luci Digital uses GitHub Actions to automate its CI/CD processes. The repository is configured to run automated tests, build the platform, and deploy code to various environments through a series of workflows.

    CI Pipeline:
        Runs on all pull requests and commits to develop and feature/* branches.
        Executes unit tests, linting, and security checks.
        Ensures code quality before merging into the main branches.

    CD Pipeline:
        Triggered on merges to the release and main branches.
        Deploys code to staging or production environments.
        Uses Docker and Ansible for containerized deployments.

    Testing Pipeline:
        Runs integration tests and end-to-end testing to ensure that the platform works as expected across different components (AI, blockchain, LoRaWAN, security).

Pull Request Workflow

    Create a feature branch from develop (or main for hotfixes).
    Develop the feature or fix in the feature branch.
    Write unit and integration tests for new features or bug fixes.
    Open a pull request to merge the feature branch into develop.
    Review the pull request:
        Ensure that all CI checks have passed.
        Review the code for quality, security, and alignment with project guidelines.
    Merge the pull request once approved and tested.
    Close the branch after the merge is complete.

Commit Message Guidelines

Follow the Conventional Commits specification for writing commit messages. This helps in generating clear change logs, improving collaboration, and automating versioning.

    feat: A new feature.
    fix: A bug fix.
    docs: Documentation updates.
    style: Code formatting and styling changes (non-functional).
    refactor: Code changes that do not introduce new features or fix bugs.
    test: Adding or updating tests.

Example:

vbnet

feat: add DID issuance via Hedera
fix: correct LoRaWAN connection issue on smart boxes
docs: update deployment guide for Apple Vision Pro integration

Repository Directories and Their Purpose

    src/ai/: Contains AI-related code and model development, split into lucia_ai for Daryl's personal AI and agent_ai for general users.
    src/blockchain/: Contains smart contracts for tokenization, DID issuance, and other blockchain-related operations.
    src/lora/: LoRaWAN network integration code for smart box connectivity and monitoring.
    src/security/: SSL/TLS encryption, firewall configurations, and security protocols.
    scripts/: Automation scripts for deployment, backup, and disaster recovery.
    tests/: Contains unit and integration tests for the various modules.

Contributions

Developers wishing to contribute to Luci Digital must adhere to the guidelines specified in the CONTRIBUTING.md file. All contributions undergo a thorough review process, ensuring that they align with the project's goals, maintain code quality, and pass all automated tests.
